
[코테 팁들 정리]

- ArrayList로 이차원 그래프 구현
    (1) 2차원 ArrayList
        static ArrayList<ArrayList<int[]>> map = new ArrayList<>();
        for(int i = 0 ; i <= N ; i++){
            map.add(new ArrayList<>());
        }

    (2) ArrayList 배열 (이게 더 와닿긴하는듯)
        static ArrayList<int[]>[] graph2 = new ArrayList[n+1];
        for(int i = 0 ; i < n+1 ; i++){
            graph2[i] = new ArrayList<>();
        }

- 위상정렬
    1. 이중 ArrayList 사용해서 arr.get(본인).add(next);로 순서 정의
    2. int[] indegree로 본인을 가르키고있는 노드의 count 저장
    3. 큐 or 우선순위큐에 indegree 0 인것들 집어넣기
    4. 하나씩 꺼내면서 로직처리후 arr의 next의 indegree값 --
    5. indegree-- 해서 0된거 존재하면 큐 or 우선순위큐에 넣기
    6. 큐 or 우선순위큐 빌때까지 반복

    ex) Topological/BOJ1766

- int[][] map에서 값을 ____ 4비트로 동서남북 가능한 방향을 표시하는 아이디어
    ex) etc/BOJ10655

- 유니온 파인드
    find : x의 부모를 찾는 연산으로 x가 parent[x]랑 같은지 확인 후 같으면 본인을 return
        다르면 parent[x]로 find연산을 다시 수행 (x==parent[x] 찾을 때 까지)
        그리고 return 시에 parent[x] = find(parent[x]); 정리해주기

    union : 먼저 find로 x와 y의 parent를 찾는다.
        만약 parent가 다르다면 연결해주기

    ex) etc/BOJ1976

- 다익스트라
    - 그래프 최단 경로 구하는 알고리즘, 양의 가중치만
    - O(mlogn)
    1. 출발지를 pq에 넣고, check를 true로, dist는 0넣기
    2. pq에서 꺼내서 now에 저장하고 방문 체크
    3. 갈수 있는 정점중 현재 dist랑 now의 dist + now에서 next거리 비교
    4. 변경되면 pq에 넣기

    ex) graph/dijkstra_basic.java

    + 플로이드 와샬 : graph/FloydWrasahll_basic , etc/BOJ10159
        => graph[i][j] = Math.min(graph[i][j], graph[i][k]+graph[k][j]) 논리

- 순열, 조합 연습
    - 순열 : etc/BOJ18429
    - 조합 : implement/BOJ15683

- 소수점 출력
    System.out.printf("%.2f",res);

- DFS를 돌릴려는데 너무 경우의 수가 많은 경우에 결정문제로 바꿔보기 (아이디어 배우기)
    문제가 어떤 거에 대한 최소/최대 값을 물을 경우
    최소/최대의 결과로 나올 수 있는 수의 범위에 대해 이분탐색을 적용
    이분 탐색으로 돌면서 해당 값이 최소/최대가 될 수 있는 지 체크!!!

- 다익스트라, 유니온 파인드, 위상정렬 시간나면 계속 반복!

- sout로 출력하는거 보다 StringBuilder가 시간복잡도 작음!!

- 조합 관련 문제를 풀때 DFS로 풀면 시간 초과날 수 있음 -> DP로 풀기
    n+1Cr+1 = nCr + nCr+1 성질 이용
    nC0 = nCn = 1

- 자바로 순열 조합 구현 DFS로 풀어보고 익숙해지면 DP도 해보자!

- DP 재귀로 풀때 DP 저장소 확인 후, 만약 값이 정해지지 않았으면 계산해서 넣어주기
    또 계산하는 과정에서 DP 재귀로 계속 들어가다가
    제일 처음 [0] or [1] 부분은 이전에 값을 넣어뒀으니 그걸 기준으로 다시 계산하면서 돌아오는 식으로  생각!

- long 타입 int 타입 조심!

- 동시 다발적으로 일어나는 경우 큐를 사용해서 BFS로 구현하는 방법
    map에다가 필요한 값 저장하는 거 생각!

- DFS BFS 문제중 안쪽 공간 신경안쓰고 외부만 신경써야하는 문제들은 map의 크기를 상하좌우 1칸씩 늘린다음
    (0,0)에서 DFS,BFS 돌리고 로직 처리하면 간단!
    -> ex) BOJ_2636 , BOJ_5547

- Arrays 익히기
    Arrays.asList(array) : 배열을 ArrayList로 바꿔줌
    Arrays.copyOf(array, copyArrayLenght) : 복사
    Arrays.copyOfRange(array, startIntex, endIndex) : 배열 부분 복사
    Arrays.fill(array, n) : 동일한 값 채우기
    Arrays.equals(array1, array2) : 배열 동일한지 비교
    Arrays.deepEquals(array1, array2) : 다차원 배열 같은지 비교
    Arrays.binarySearch() : 배열의 요소를 검색하여 인덱스 반환 (sort하고 사용해라)
        - 없으면 음수 리턴
    Arrays.sort(array) : 정렬

- 백트래킹 + 조합 idea (samsung/BOJ_14889 요약)
    문제가 만약 모든 상황을 고려해야할때(조합)
    - 모든 상황을 DFS 조합으로 만들고
    - 각 상황에 대해서 팀의 값 차이를 비교(추가적인 로직)한다

- 백트래킹은 전략 짜는게 중요한듯
    - 어떤식으로 DFS에 들어갈지
    - 매개변수를 어떤 식으로 정할지 (최대한 단순화)
    - 정지 조건도 중요!
    - 트리 짜를수있는 경우 있으면 짜르기

- map에서 동,남,서,북(시계) 움직일때
    static int[] dx = {0,1,0,-1};
    static int[] dy = {1,0,-1,0};
    - 여기서 dx값이 map[x][y]에서 x 이동 -> 위아래 이동
    - 여기서 dy값이 map[x][y]에서 y 이동 -> 왼쪽 오른쪽으로 이동

- 조합 방식 생각하기
    - 1부터 N까지의 모든 수 중, M개를 고르는 상황일 때
    - 매개변수 : idx(해당 index 뒤에 숫자 중 하나 선택), count(선택 갯수)
    private static void chickenDFS(int idx, int count) {
        // 정지 조건
        if(count == M){
            ~
        }

        // DFS 들어가기
        for(int i = idx ; i < chickens.size() ; i++){
            picks.add(i); // -> int[] M개 배열에 담는게 더 속도 빠를듯
            chickenDFS(i+1,count+1);
            picks.remove(picks.size()-1);
        }
    }

- 특정값을 % N해서 범위 안에 넣어야하는 상황일 때, 만약 결과가 음수가 나오면
    c[0] = (c[0]+dx[d]*s)%N;
    c[0] = c[0] < 0 ? c[0]+N : c[0];
    이렇게 음수면 +N 한번 더 해주면됨

- 자료구조에 따라 속도에 영향이 잘 미치지 않는 경우에는
    자료구조 고민보단 빠르게 뭘 사용할지 결정하고
    코드 짜는게 나을듯?

- 예를들어 N개의 보기 중 조합 방식으로 M개 선택하고 DFS 돌리는 문제일때
    N개의 보기중에 M개를 선택하는 DFS를 하나 만들고
    그 안에서 count == M 을 만족했을 때, 또 DFS를 하나 더 돌려서 해결하자

- 문제 잘 읽는것이 제일 기본!!

- 2차원 배열 움직임 연습하기
    ex) samsung/BOJ_17144

- BufferedWriter도 익숙해지자
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    bw.write(meteorCal() + "");
    bw.flush();
    bw.close();
    br.close();
    마지막 close도 잊지말기!

- ArrayList<meteor>에 정보들 모두 저장
    배열 한바퀴 돌면서 파이어볼 이동시키고 결과 ArrayList<meteor>[][] map;에 저장
    map[][] 돌면서 하나의 칸에 2개 이상있으면 분열 계산하고

    ArrayList<meteor>[][] map에 대해 이미지 머리에 그리기
        -> 각 map[][]이라는 2차원 배열에 meteor를 담는 ArrayList 주소가 담기는거!

- 2차원 배열 문제에서 행과 열에 따로따로 적용해야하는 문제에 대해서
    행에 대해서만 함수를 만들고 배열 상태를 행과 열을 뒤집어 해당 함수로 한번 더 적용하는 아이디어

- 자유자재로 DFS로 조합/백트래킹 구현하고 BFS도 할줄 알도록 익숙해지는게 중요 !!
    -> 문제푸는것보다 중요

- for(int j = temp.size()-1 ; j >= 0  ; j--){}
    ArrayList temp 뒤에서 부터 돌기

- 자료구조에 따라 연산의 시간 복잡도랑 자료구조 이미지 머리에 그리기!!!
    - ArrayList : 일반 배열 - add 어떻게 되는거지?
        - get(idx) : O(1)
        - add() : O(1)
        - remove()/insert()/contains : O(n)
    - LinkedList : Linked 배열
        - get(idx) : O(n)
        - add()/insert() : O(1) amortized // 흠..
        - remove() - 접근하는데 시간걸림 / contains : O(n)
    - HashSet : 순서 x , null 가능
        - add() : O(1)
        - contains() : O(1)
    - LinkedHashSet : 순서 o , null 가능
        - add() : O(1)
        - contains() : O(1)
    - HashMap : key-value, 순서 x, null 가능
        - get() : O(1)
        - containsKey() : O(1)
    - LinkedHashMap : key-value, 순서 o, null 가능
        - get() : O(1)
        - containsKey() : O(1)
    - PriorityQueue
        - offer() : O(logN)
        - peek() : O(1)
        - poll() : O(logN)
        - size() : O(1)
     - Queue = LinkedList
        - offer()/Enqueue : O(1)
        - peek() : O(1)
        - poll()/Dequeue : O(1)
        - size() : O(1)
        - search : O(n)
     - Stack
        - push : O(1)
        - pop : O(1)
        - peek(idx) : O(n)
     - Deque = LinkedList
        - 앞추가 : addFirst() / 뒷추가 : addLast()
        - 앞삭제 : remove()-poll() / 뒷삭제 : remove-pollLast()
        - 앞조회 : peek() / 뒷조회 : peekLast()

- 반복문으로 특정 자료구조 순회하고 있을 때,
    해당 자료구조에 삽입/삭제를 하게 되면 순서 꼬일 수 있다 !! 조심!!

- map[][] 그래프 감각을 더 키워야할듯!

- DFS나 BFS에서 모든 빈칸에 들어갔는지 체크할 경우
    - 먼저 첫 map을 초기화할때 빈칸의 갯수를 zero_cnt++를 통해 체크를한다.
    - 그리고 DFS/BFS를 돌면서 조건을 만족하여 해당 위치로 이동할때 cnt++를한다.
    - 다돌고나서 zero_cnt == cnt 이면 모든 칸을 들어간것임
    - 이렇게 하면 추가적인 시간복잡도 없이 해결 가능 !!

- DFS 조합시에 선택완료 or 선택을 둘로 나누고 구현하다
    - 이 때 선택 과정에서 combi 매개변수 조심!!!!
    - 계속 실수로 idx 값을 넣는데 i 값을 넣어야 한다

- Arrays.sort 또는 Collections.sort 할때
    - (o1,o2)에서 작은 값부터 정렬 (오른차순 정렬)을 할려면 return o1-o2;를 해라
    - 즉, 순서대로 빼면 오름차순임!

- 당연한 얘기지만 BFS로 조건을 만족하는 가장 가까운 대상을 찾을 때,
    대상을 찾고나서 변화하는 것에 대해서는 신경안써도 됨!

- map[][]에서 이동 방향에 따라 주변에 변화가 다르게 적용되는 문제
    - dx,dy는 평소처럼 사용
    - dx,dy 이동 방향에 따라 이동량이 다른 경우에는 numOfMove도 방향에 맞게 정의
    - dx,dy 방향에 맞게 변화 위치를 dxOf[][], dyOf[][]에 정의
    - 만약 위치에 따라 값도 변화한다면 dxOf,dyOf에 2차배열순서에 맞게 값도 적용 ratioOf등으로
    - ex) samsung/BOJ_20057

- 주사위 문제에서
    - 특정 값이 바닥에 있을 때, 동서남북 방향에 값이 항상 바뀜
    - 즉, 미리 특정 숫자의 동쪽에 어떤 숫자가 있다고 배열로 미리 설정하는 방식 x
    - 굴릴때마다 배열에 값 넣는 방식으로 하자

- 변하는 값이 규칙이 없다면 배열을 활용해라
    - 예를들어, 방향을 가지고 있는 상황이고 조건에 따라 시계 방향, 반시계 방향으로 바꾸는 상황이라고 가정하자
    - 이때, 만약 시계/반시계 방향으로 돌리는 것에 규칙이 없다면 static int[][] dir = {{1,2},{3,0},{0,3},{2,1}};
    - 이런식으로 방향이 0일때 시계 : d = dir[d][0] / 반시계 : d = dir[d][1] 이런 식으로 구현 가능

- 2차원 배열에 동서남북 방향에 따라 어떤 메소드를 적용하는 문제에서
    - 방향에 따라 다르게 메소드를 구현하는 것이 어려울 때 팁 !
    - 메소드는 가장 구현하기 쉬운 하나의 방향으로 구현하고 적용하기전에 map[][]을 시계/반시계/.. 이렇게 뒤집어서 메소드 적용

- map[][]이 있는 상황에서 메소드(ex. dfs)에 매개변수에 넣을 때,
    - map[][]을 넣으면 깊은 복사 적용되어서 값만 복사됨
    - 하지만 map[]을 넣으면 해당 배열 주소가 얕은 복사가 되어서 메소드에서 값 바뀌면 그것이 map[][]에 반영이 됨.

- 배열 clone , Arrays.copyOfv하면 깊은 복사 즉, 값들만 복사됨

- 배열 n번 shift 하는 방법
    1. 2차원 for문으로 직접 다 밀기
    2. 같은 크기의 배열 temp하나 만들어서 shift한 결과를 다 저장하고 배열주소 넣기 <= 이걸로 하자
        -> shift할때 값 덮어써서 곂치는 부분 생각안해도 됨
    3. 마지막에 겹치는 부분 따로 저장해두고 다 shift하기

- 백트래킹 + 조합 구현
    backtracking(){
        // 1. 모든 선택 완료일 경우 + return;

        // 2. for문으로 현재상황에서 선택할 수 있는 모든 상황에 대해서 백트래킹
        //      -> for문 돌리고 해당 i에 대해서 다음 depth에 변경되는 값들 계산해서
        //      -> 값넣고 visit 체크하고 다음 backtracking() 들어가기
        //      -> 나오고 나서 값들이랑 visit 원래대로 돌리기
    }

- 방향에 따라 다르게 그 방향에 맞게 적용하는 문제는 모든 경우를 하나의 방향으로 적용하여
    - 값만 바꾸어 그 방향으로 적용하면 풀리는 경우가 많다!!!!

- 2차원 배열에서 아래쪽으로 shift할때
    - 마지막에 new boolean해줘야한다. 안하면 map[0]이랑 map[1]의 주소가 같아진다.
    예시) for(int i = 5 ; i > 0 ; j--){
             map[i] = map[i-1];
         }
         map[0] = new boolean[4];

- 2차원 배열 boolean[][] map = new boolean[5][5]에서
    - 만약 boolean[1]이 모두 true or false 일때 조건 발생
        : boolean flag = false하고 for(i)문 돌면서 if(!map[i][j]) flag = true;
           다 돌았을때, flag가 그대로 false이면 조건 발생
    - 만약 boolean[1]이 하나라도 true일때 조건 발생
        : for(i)문돌리고 if(boolean[1][i]){조건}, 조건 끝나면 상황에 따라 break or continue;
    - 만약 boolean[1]이 하나라도 false일때 조건 발생
        : for(i)문돌리고 if(!boolean[1][i]){조건}, 조건 끝나면 상황에 따라 break or continue;

- 구현문제에서 int[][] map에 원소들 넣고 HashMap<Integer,int[]> hm에 i,j,d를 추가하는 식으로 구현할 경우
    - 항상 map과 hm은 세트라는 걸 잊지말자 !!
    - 즉, map이 바뀌는 상황에서는 항상 hm에도 반영이 되어야하고 그 반대도 마찬가지!
    - 백트래킹을 사용했을 때도, 매개변수로 map을 넣어야한다면 hm도 매개변수로 사용함을 잊지말자

- map을 사용하는 문제에서 백트래킹으로 구현하는 경우
    - 각 상황(백트래킹 깊이)마다 map의 변경이 많아서 다시 이전 map으로 되돌릴 수 없는 상황이라면
    - static map으로 하지말고 새로운 newMap을 할당받아 clone을 한뒤 매개변수로 넣어줘라 !!
    - 메모리는 많이 들지만(조심), 구현상으로는 훨씬 편할 수 있음 !!
    - 매개 변수 넣을때, map이랑 세트인 저장소가 있다면, 걔들도 같이 매개변수가 되어야 함
        : 그렇지 않으면 각 backtracking들이 서로 영향을 준다!

- ArrayList<int[]>[][] map : int[] 주소를 ArrayList로 저장하는 자료구조의 주소를 2차원 배열로 저장하는 map
    - space라는 class로 space[][] map = new space[N][N];를 하면 현재 이것은 space의 주소를 저장할 2차원 공간만 확보한 것!
    - space 자료구조를 생성한것이 아님!!
    - 따라서 for-i,j 돌면서 map[i][j] = new space();로 할당을 해주어야 한다.

- 그냥 x,y와 같은 위치만을 나타내는 간단한 객체들은 int[]로 구현하지만, 복잡해지고 타입을 많이 가져야하는 경우는 class를 정의하자

- ArrayList<Integer> temp에서 for(int t : temp)를 돌리면 t는 그냥 값만 복사한 것
    - 이때 temp.remove 하면 에러뜸 (ArrayList<int[]> 도 마찬가지)
    - 또한 t 값을 바꾸면 temp에 반영이 안되기때문에 반영하고 싶으면 temp.set을 써라

- 행(i)이 가장 큰 것을, 그것도 여러개면 열(j)이 가장 큰 것
    - 우선 순위가 i 부터, 근데 i가 같으면 j로
        ex) if(o2.basic.i == o1.basic.i){
                return o2.basic.j - o1.basic.j;
            }else{
                return o2.basic.i - o1.basic.i;
            }

- 완전 탐색에서 모든 조합 상황에 대해 특정 갑의 최솟값을 찾는 문제에서 최솟값을 가지는 조합상황이 여러 개 일때
    - 해당 상황을 모두 ArrayList에 넣고 마지막에 정렬해서 출력하는게 속도 더 빠름

- 문자열 합칠때는 String 사용하지말고 StringBuilder 적극 활용해라 !
    - String은 불면이기 때문에 A 문자열과 B 문자열을 합칠 때, C배열을 새로 선언한다음 A와 B를 복사하는 방식임
    - StringBuilder는 불변이 아니고, 미리 일정한 크기의 배열을 잡아두고 거기에 붙여나가는 방식

- StringBuilder 시간 복잡도
    - append(String str) : str 길이가 n일때 O(n)
    - insert(int offset, String str) : O(n + m)
    - delete : O(n)
    - deleteCharAt : O(n)
    - replace(int start, int end, String str) : O(n + m) - 현재 버퍼 : n , 대입할려는 문자열 : m
    - reverse() : 현재 버퍼의 길이가 n이면 O(n)
    - indexOf(String str) : O(n)

- BFS 처럼 큐에 값넣고 처리하는 방식 설계 시 조심!!
    - 예를들어 (0~49) 사이즈의 배열을 큐에 넣고 양쪽에 하나씩 줄이면서 큐에 넣는 상황일 때
    - (1~49) (0~48) -> (2~49) (1~48) (1~48) (0~47) 즉, 이렇게 겹치는 상황이 생김
    - 겹치는 상황인지 아닌지 판단잘하자!!
    - 이러한 경우 그냥 BFS 필요없이 배열로 해결가능한 경우 있음 <- 훨씬 간단

- DFS나 BFS 적용할 때, 깊이 관점에서 머리에서 시뮬레이션 돌려서 더 속도 빠른 거 채택하자

- map[N][M]에서 백트래킹들어갈 때, 매개변수에 count 넣기
    - int x = count / M;
    - int y = count % M;
    - if(count == N*M) return;
    - 이러면 map[x][y] 모두 접근 가능

- dp 문제는 모든 상황에서 규칙적인 현재 상황과 이전 상황이 존재하는지 체크
    - 있다면 그것을 식으로 정의하는 것이 중요

- 불가능한 상황에 대해 -1 출력하라는거 놓치지말자 !

