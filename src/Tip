
[코테 팁들 정리]

- ArrayList로 이차원 그래프 구현
    (1) 2차원 ArrayList
    static ArrayList<ArrayList<int[]>> map = new ArrayList<>();

    for(int i = 0 ; i <= N ; i++){
        map.add(new ArrayList<>());
    }

    (2) ArrayList 배열 (이게 더 와닿긴하는듯)
    static ArrayList<int[]>[] graph2;

    graph2 = new ArrayList[n+1];
    for(int i = 0 ; i < n+1 ; i++){
        graph2[i] = new ArrayList<>();
    }

- 위상정렬
    1. 이중 ArrayList 사용해서 arr.get(본인).add(next);로 순서 정의
    2. int[] indegree로 본인을 가르키고있는 노드의 count 저장
    3. 큐 or 우선순위큐에 indegree 0 인것들 집어넣기
    4. 하나씩 꺼내면서 로직처리후 arr의 next의 indegree값 --
    5. indegree-- 해서 0된거 존재하면 큐 or 우선순위큐에 넣기
    6. 큐 or 우선순위큐 빌때까지 반복

    ex) Topological/BOJ1766

- Arrays.copyOf(arr,n);
    arr배열의 원소 n개 복사

- int[][] map에서 값을 ____ 4비트로 동서남북 가능한 방향을 표시하는 아이디어
    ex) etc/BOJ10655

- 유니온 파인드
    find : x의 부모를 찾는 연산으로 x가 parent[x]랑 같은지 확인 후 같으면 본인을 return
        다르면 parent[x]로 find연산을 다시 수행 (x==parent[x] 찾을 때 까지)
        그리고 return 시에 parent[x] = find(parent[x]); 정리해주기

    union : 먼저 find로 x와 y의 parent를 찾는다.
        만약 parent가 다르다면 연결해주기

    ex) etc/BOJ1976

- 다익스트라
    - 그래프 최단 경로 구하는 알고리즘, 양의 가중치만
    - O(mlogn)
    1. 출발지를 pq에 넣고, check를 true로, dist는 0넣기
    2. pq에서 꺼내서 now에 저장하고 방문 체크
    3. 갈수 있는 정점중 현재 dist랑 now의 dist + now에서 next거리 비교
    4. 변경되면 pq에 넣기

    ex) graph/dijkstra_basic.java

    + 플로이드 와샬 : graph/FloydWrasahll_basic , etc/BOJ10159
        => graph[i][j] = Math.min(graph[i][j], graph[i][k]+graph[k][j]) 논리

- 순열, 조합 연습
    - 순열 : etc/BOJ18429
    - 조합 : implement/BOJ15683

- 소수점 출력
    System.out.printf("%.2f",res);

- DFS를 돌릴려는데 너무 경우의 수가 많은 경우에 결정문제로 바꿔보기 (아이디어 배우기)
    문제가 어떤 거에 대한 최소/최대 값을 물을 경우
    최소/최대의 결과로 나올 수 있는 수의 범위에 대해 이분탐색을 적용
    이분 탐색으로 돌면서 해당 값이 최소/최대가 될 수 있는 지 체크!!!

- 다익스트라, 유니온 파인드, 위상정렬 시간나면 계속 반복!







